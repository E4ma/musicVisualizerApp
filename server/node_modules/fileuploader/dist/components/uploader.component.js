"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var JSZip = require("jszip");
var UploaderComponent = (function () {
    /**
     * Constructor
     */
    function UploaderComponent(element) {
        this.maxSize = 0;
        this.multiple = true;
        this.encode = false;
        this.invalidFilemsg = 'Invalid File';
        this.invalidFormatmsg = 'Invalid Format!';
        this.results = new core_1.EventEmitter();
        this.fail = new core_1.EventEmitter();
        this.dragging = false;
        this.files = [];
        this.mFile = null;
        this.encoded = [];
        this.imgSrc = '';
        this.jszip = new JSZip();
        this.failed = new Array();
        this.hasFile = false;
        this.myElement = element;
    }
    UploaderComponent.prototype.handleFileOver = function (event) {
        this.dragging = event;
    };
    UploaderComponent.prototype.handleFileLoad = function (files) {
        console.log(files);
        this.dragging = false;
        if (files.length > 0) {
            if (this.type === 'image') {
                var file = files[0];
                this.handleImageLoad(file);
            }
            else if (this.type === 'invoice') {
                this.handleInvoiceLoad(files);
            }
            else {
                if (this.multiple) {
                    this.loadMultiple(files);
                }
                else {
                    this.loadSingle(files[0]);
                }
            }
            if (this.failed.length > 0) {
                var str = this.invalidFilemsg + ': ';
                while (this.failed.length > 0) {
                    str += this.failed.pop();
                    if (this.failed.length > 0) {
                        str += ', ';
                    }
                }
                this.fail.emit(str);
                alert(str);
            }
        }
    };
    UploaderComponent.prototype.loadFiles = function (event) {
        var fileList = event.dataTransfer ? event.dataTransfer.files : event.target.files;
        console.log(fileList);
        this.handleFileLoad(fileList);
    };
    UploaderComponent.prototype.onChange = function (event) {
        console.log(event);
        this.loadFiles(event);
        this.input.nativeElement.value = '';
    };
    UploaderComponent.prototype.addFiles = function () {
        this.input.nativeElement.click();
    };
    UploaderComponent.prototype.handleImageLoad = function (file) {
        var reader = new FileReader();
        if (file.type.match('image/jpeg')) {
            reader.onload = this._handleReaderLoaded.bind(this);
            reader.readAsDataURL(file);
            this.files.push(file);
        }
        else {
            alert(this.invalidFormatmsg);
            return;
        }
    };
    UploaderComponent.prototype.loadSingle = function (file) {
        if (this.maxSize !== null && this.maxSize > 0) {
            if (file.size > this.maxSize) {
                return;
            }
        }
        if (!this.matchesExtension(file)) {
            return;
        }
        this.mFile = file;
        if (this.encode) {
            this.getBase64(file);
        }
        var res = new Object();
        res.msg = 'loaded file';
        res.file = this.mFile;
        this.results.emit(res);
    };
    UploaderComponent.prototype.loadMultiple = function (files) {
        if (files.length > 0) {
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                if (this.maxSize !== null && this.maxSize > 0) {
                    if (file.size > this.maxSize) {
                        this.failed.push(file.name);
                        continue;
                    }
                }
                if (!this.matchesExtension(file)) {
                    this.failed.push(file.name);
                    continue;
                }
                this.files.push(file);
                if (this.encode) {
                    this.getBase64(file);
                }
            }
            var res = new Object();
            res.msg = 'loaded files';
            res.files = this.files;
            this.results.emit(res);
        }
    };
    UploaderComponent.prototype.cleanFiles = function () {
        this.input.nativeElement.value = '';
        this.files = [];
    };
    UploaderComponent.prototype.handleInvoiceLoad = function (files) {
        var _this = this;
        if (files.length > 0) {
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                if (this.maxSize !== null && this.maxSize > 0) {
                    if (file.size > this.maxSize) {
                        this.failed.push(file.name);
                        continue;
                    }
                }
                if (this.handleExtension(file) == 0) {
                    this.files.push(file);
                    if (this.encode) {
                        this.getBase64(file);
                    }
                }
                else if (this.handleExtension(file) == 1) {
                    this.jszip.loadAsync(file)
                        .then(function (configZip) {
                        configZip.forEach(function (filePath, file) {
                            if (!file.dir) {
                                var filename_1 = file.name.split('/').pop();
                                if ((filename_1.indexOf('.') !== 0)) {
                                    file.async("blob").then(function (content) {
                                        var f = new File([content], filename_1);
                                        _this.files.push(f);
                                        if (_this.encode) {
                                            _this.getBase64(f);
                                        }
                                    });
                                }
                            }
                        });
                    });
                }
                else {
                    this.failed.push(file.name);
                }
            }
            if (this.files.length > 0) {
                this.results.emit(this.files);
            }
            if (this.failed.length > 0) {
                var str = this.invalidFilemsg + ': ';
                while (this.failed.length > 0) {
                    str += this.failed.pop();
                    if (this.failed.length > 0) {
                        str += ', ';
                    }
                }
                alert(str);
            }
        }
    };
    UploaderComponent.prototype.handleExtension = function (file) {
        var name = file.name.toLowerCase();
        var ext = name.split('.').pop();
        if (ext === 'zip') {
            return 1;
        }
        return 0;
    };
    UploaderComponent.prototype.matchesExtension = function (file) {
        if (this.accepted.length === 0) {
            return true;
        }
        var ext = file.name.toLowerCase().split('.').pop();
        if (this.accepted.indexOf(ext) !== -1) {
            return true;
        }
        return false;
    };
    UploaderComponent.prototype._handleReaderLoaded = function (e) {
        var reader = e.target;
        var img = document.createElement("img");
        img.src = reader.result;
        this.imgSrc = this.resize(img);
        this.results.emit(this.imgSrc);
    };
    UploaderComponent.prototype.resize = function (img) {
        var canvas = document.createElement("canvas");
        canvas.width = 100;
        canvas.height = 100;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, 100, 100);
        var dataUrl = canvas.toDataURL('image/jpeg');
        return dataUrl;
    };
    UploaderComponent.prototype.setStyles = function () {
        return this.looks;
    };
    UploaderComponent.prototype.getBase64 = function (file) {
        var reader = new FileReader();
        reader.onload = this.convertbase64.bind(this);
        reader.readAsDataURL(file);
    };
    UploaderComponent.prototype.hasFiles = function () {
        if (this.multiple) {
            return this.files.length > 0;
        }
        else {
            return this.mFile ? true : false;
        }
    };
    UploaderComponent.prototype.convertbase64 = function (e) {
        var reader = e.target;
        if (this.multiple) {
            this.encoded.push(reader.result);
        }
        else {
            this.encoded = [];
            this.encoded.push(reader.result);
        }
    };
    UploaderComponent.prototype.downloadSingleFile = function (name, encoded) {
        if ((encoded && this.encoded.length > 0) || (this.mFile)) {
            var downloadSingle = document.createElement('a');
            if (encoded) {
                downloadSingle.setAttribute('href', 'application/octet-stream;base64,' + encoded[0]);
            }
            else {
                var url = window.URL.createObjectURL(this.mFile);
                downloadSingle.href = url;
            }
            downloadSingle.download = name ? name : this.mFile.name;
            document.body.appendChild(downloadSingle);
            downloadSingle.click();
            document.body.removeChild(downloadSingle);
        }
    };
    UploaderComponent.prototype.downloadFromList = function (index, name, encoded) {
        if ((encoded && this.encoded && index < this.encoded.length) || (this.files && index < this.files.length)) {
            var download = document.createElement('a');
            if (encoded) {
                download.setAttribute('href', 'application/octet-stream;base64,' + encoded[index]);
            }
            else {
                var url = window.URL.createObjectURL(this.files[index]);
                download.href = url;
            }
            download.download = name ? name : this.files[index].name;
            document.body.appendChild(download);
            download.click();
            document.body.removeChild(download);
        }
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "type", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "userImg", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "cpntID", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "accepted", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Number)
    ], UploaderComponent.prototype, "maxSize", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], UploaderComponent.prototype, "looks", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], UploaderComponent.prototype, "multiple", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], UploaderComponent.prototype, "encode", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "invalidFilemsg", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], UploaderComponent.prototype, "invalidFormatmsg", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], UploaderComponent.prototype, "results", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], UploaderComponent.prototype, "fail", void 0);
    __decorate([
        core_1.ViewChild("input"),
        __metadata("design:type", core_1.ElementRef)
    ], UploaderComponent.prototype, "input", void 0);
    UploaderComponent = __decorate([
        core_1.Component({
            selector: 'uploader',
            styles: ["\n        .uploadContainer {\n            background: #F9F9F9;\n            outline: dotted 3px #ccc;\n            cursor: pointer;\n            height: 100%;\n            max-height: 100%;\n            overflow-y:auto;\n        }\n\n        .uploaderWithoutFile {\n            max-height: 100%;\n            max-width: 100%;\n        }\n\n        .uploaderWithFile {\n            max-height: 100%;\n            max-width: 100%;\n        }\n    "],
            template: "\n    <div class=\"uploadContainer\" [style.outlineColor]=\"dragging ? 'red' : '#ccc'\" fileDropDirective (fileOver)=\"handleFileOver($event)\" (onFileDrop)=\"handleFileLoad($event)\" [ngStyle]=\"setStyles()\">\n        <input type=\"file\" #input [hidden]=\"true\" [id]=\"cpntID\" (change)=\"onChange($event)\" multiple=\"multiple\" [accept]=\"accepted\">\n        <div *ngIf=\"!hasFiles()\">\n            <ng-content select=\"uploader-without-file\" class=\"uploaderWithoutFile\"></ng-content>\n        </div>\n        <div *ngIf=\"hasFiles()\">\n            <ng-content select=\"uploader-with-file\" class=\"uploaderWithFile\"></ng-content>\n        </div>\n    </div>\n    ",
        }),
        __metadata("design:paramtypes", [core_1.ElementRef])
    ], UploaderComponent);
    return UploaderComponent;
}());
exports.UploaderComponent = UploaderComponent;
//# sourceMappingURL=uploader.component.js.map